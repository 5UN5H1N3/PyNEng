# Параллельные сессии

Мы уже научились подключаться к оборудованию, используя различные модули Python. Но, конечно же, хотелось бы подключаться к нескольким устройствам параллельно.

Ведь, если нам нужно опросить много устройств, то выполнение подключений поочередно, будет достаточно долгим.
И, если подключение к 100 устройствам будет еще относительно недолгим, то к 1000 уже придется достаточно долго ждать.

Конечно, это будет быстрее, чем подключение вручную. Но, хотелось бы подключаться отклик как можно быстрее.

> Все эти "долго" и "быстрее" относительные понятия. Но, в этом разделе мы научимся и конкретно измерять сколько отрабатывал скрипт, чтобы сравнить насколько быстрее будет выполняться подключение.

Для того чтобы ускорить подключение к нескольким устройствам, мы будем использовать два модуля:
* threading
* multiprocessing

## Измерение времени выполнения скрипта

Для оценки времени выполнения скрипта есть несколько вариантов. Мы будем использовать самые простые варианты:
* утилиту Linux time
* и модуль Python datetime

Рассматриваем оба варианта, на тот случай, если вы не используете Linux.

Тут нам не важна высокая точность, а главное сравнить время выполнения скрипта в разных вариантах.

###```time```

Утилита time в Linux позволяет легко замерить время выполнения скрипта. Например:
```
$ time python thread_paramiko.py
...
real    0m4.712s
user    0m0.336s
sys     0m0.064s
```

Нас интересует real время. В данном случае, это 4.7 секунд.

Как видите, утилитой time пользоваться очень легко - просто пишите time перед строкой запуска скрипта.

###```datetime```

Второй вариант, который вы можете использовать - модуль datetime.
Этот модуль позволяет работать с временем и датами в Python.

Мы будем его использовать в таком виде:
```python
from datetime import datetime
import time

start_time = datetime.now()

#Тут будет наша программа
time.sleep(5)

print datetime.now() - start_time
```

В этом примере мы просто делаем паузу на 5 секунд и всё. И смотрим, что нам покажет модуль datetime:
```
$ python test.py
0:00:05.004949
```

Остальное, думаю, достаточно понятно.

## Проблемы с потоками в Python (CPython)

<br>
> Подробности, которые описаны ниже не обязательно знать. В общем случае, лучше использовать модуль multiprocessing и можно плюс-минус не задумываться обо всех этих особенностях. 


Для начала, нам нужно разобраться с терминами:
* процесс (process) - это, грубо говоря, запущенная программа. Процессу выделяются отдельные ресурсы: память, процессорное время
* поток (thread) - это единица исполнения в процессе. Потоки разделяют ресурсы процесса, к которому они относятся.

Python (а точнее, CPython - реализация о которой мы говорим всё это время) оптимизирован для работы в однопоточном режиме. Это хорошо, если в нашей программе используется только один поток.

И, в то же время, у Python есть определенные нюансы работы в многопоточном режиме. Связаны они с тем, что CPython использует GIL (global interpreter lock).

GIL не дает нескольким потокам исполнять одновременно код Python.
Если не вдаваться в подробности (а они довольно сложные), то GIL можно представить как некий переходящий флаг, который разрешает потокам выполняться.
У кого флаг, тот может выполнять работу.

Флаг передается либо каждые сколько-то инструкций Python, либо, например, когда выполняются какие-то операции ввода-вывода.

Поэтому, получается, что фактически разные потоки не будут выполняться параллельно, а программа просто будет между ними переключаться, выполняя их в разное время.

Но, не всё так плохо. Если в нашей программе есть некое "ожидание": пакетов из сети, запроса пользователя, пауза типа sleep, то в такой программе потоки будут выполняться как-будто параллельно.
А всё потому, что, во время таких пауз, флаг (GIL) можно передать другому потоку.

Но, тут также нужно быть осторожным, так как такой результат может наблюдаться на небольшом количестве сессий, но может ухудшиться с ростом количества сессий.

В любом случае, у потоков в Python есть свои области применения. Мы посмотрим как можно их использовать для подключения по Telnet/SSH и посмотрим на то, какое суммарное время будет занимать исполнение скрипта, по сравнению с последовательным исполнением и с использованием процессов.

## Процессы

Обычно, чтобы не погружаться во все эти тонкости с GIL и потоками в Python, проще просто использовать модуль multiprocessing и всё.

Если же вы столкнетесь с ситуацией где вам нужно будет использовать потоки, скорее всего, к тому времени вы уже разберетесь с этим вопросом. Как минимум достаточно в целом знать об описанных выше особенностях.

## Дополнительная информация

Если вы хотите подробнее разобраться с этими вопросами, или захотите вернуться к ним позже, несколько ссылок:
* GIL:
 * [GIL](http://asvetlov.blogspot.com/2011/07/gil.html) (на русском)
 * [Inside the Python GIL](http://www.dabeaz.com/python/GIL.pdf)
* Отличная статья [Python threads and the GIL](http://jessenoller.com/blog/2009/02/01/python-threads-and-the-global-interpreter-lock)
* Коротко о GIL, threads, processes:
 * http://stackoverflow.com/questions/3044580/multiprocessing-vs-threading-python
 * http://stackoverflow.com/questions/18114285/python-what-are-the-differences-between-the-threading-and-multiprocessing-modul
