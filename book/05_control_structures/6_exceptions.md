## Работа с исключениями try/except/else/finally
### try/except
Если вы повторяли примеры, которые использовались ранее, то наверняка были ситуации, когда выскакивала ошибка. Скорее всего, эта была ошибка синтаксиса, когда не хватало, например, двоеточия.

Как правило, Python довольно понятно реагирует на подобные ошибки и их можно исправить.

Но, даже если код синтаксически написан правильно, все равно могут возникать ошибки. Это ошибки называются __исключения (exceptions)__.

Примеры исключений:
```python
In [1]: 2/0
-----------------------------------------------------
ZeroDivisionError: integer division or modulo by zero

In [2]: 'test' + 2
-----------------------------------------------------
TypeError: cannot concatenate 'str' and 'int' objects
```

В данном случае, мы увидели два исключения: __ZeroDivisionError__ и __TypeError__.

Чаще всего, мы можем предсказать какого рода исключения возникнут во время исполнения программы.

Например, если программа на вход ожидает два числа, а на выходе выдает их сумму, а пользователь ввел вместо одного числа, строку, то мы увидим ошибку TypeError, как в примере выше. 

Python позволяет нам работать с исключениями. Мы можем их перехватывать и что-то выполнять, в случае, если возникло определенное исключение.

Для работы с исключениями используется конструкция try/except:
```python
In [3]: try:
   ...:     2/0
   ...: except ZeroDivisionError:
   ...:     print "You can't divide by zero"
   ...:     
You can't divide by zero
```

Конструкция try работает таким образом:
* сначала выполняются выражения, которые записаны в блоке try
* если при выполнения блока try, не возникло никаких исключений, блок except пропускается. И выполняется дальнейший код
* если во время выполнения блока try, в каком-то месте, возникло исключение, оставшаяся часть блока try пропускается
 * если в блоке except указано исключение, которые возникло, выполняется код в блоке except
 * если исключение, которое возникло, не указано в блоке except, выполнение программы прерывается и выдается ошибка

Обратите внимание, что строка 'Cool!' в блоке try не выводится:
```python
In [4]: try:
   ...:     print "Let's divide some numbers"
   ...:     2/0
   ...:     print 'Cool!'
   ...: except ZeroDivisionError:
   ...:     print "You can't divide by zero"
   ...:     
Let's divide some numbers
You can't divide by zero
```

В конструкции try/except может быть много except, если нужны разные действия, в зависимости от ошибки.

Например, у нас есть скрипт (divide.py), который делит два числа введенных пользователем:
```python
# -*- coding: utf-8 -*-

try:
    a = raw_input("Введите первое число: ")
    b = raw_input("Введите второе число: ")
    print "Результат: ", int(a)/int(b)
except ValueError:
    print "Пожалуйста, вводите только числа"
except ZeroDivisionError:
    print "На ноль делить нельзя"
```

Примеры выполнения скрипта:
```python
nata$ python divide.py
Введите первое число: 3
Введите второе число: 1
Результат:  3

nata$ python divide.py
Введите первое число: 5
Введите второе число: 0
Результат:  На ноль делить нельзя

nata$ python divide.py
Введите первое число: qewr
Введите второе число: 3
Результат:  Пожалуйста, вводите только числа
```

В данном случае, исключение __ValueError__ возникает когда пользователь ввел строку, вместо числа. И во время перевода строки в число возникла ошибка.

Исключение ZeroDivisionError возникает в случае, если второе число было 0.

Если мы не ходим выводить различные сообщения на ошибки ValueError и ZeroDivisionError, можно сделать так:
```python
# -*- coding: utf-8 -*-

try:
    a = raw_input("Введите первое число: ")
    b = raw_input("Введите второе число: ")
    print "Результат: ", int(a)/int(b)
except (ValueError, ZeroDivisionError):
    print "Что-то пошло не так..."
```

Проверяем:
```python
nata$ python divide.py
Введите первое число: wer
Введите второе число: 4
Результат:  Что-то пошло не так...

nata$ python divide.py
Введите первое число: 5
Введите второе число: 0
Результат:  Что-то пошло не так...
```


> В блоке except можно не указывать конкретное исключение или исключения. В таком случае, будут перехватываться все исключения.

> __Это делать не рекомендуется!__


### try/except/else
В конструкции try/except есть опциональный блок else. Он выполняется в том случае, если не было исключения.

Например, если нам надо выполнять в дальнейшем какие-то операции с данными, которые ввел пользователь, мы можем записать из в блоке else: 
```python
# -*- coding: utf-8 -*-

try:
    a = raw_input("Введите первое число: ")
    b = raw_input("Введите второе число: ")
    result = int(a)/int(b)
except (ValueError, ZeroDivisionError):
    print "Что-то пошло не так..."
else:
    print "Результат в квадрате: ", result**2
```

Пример выполнения:
```python
nata$ python divide.py
Введите первое число: 10
Введите второе число: 2
Результат в квадрате:  25

nata$ python divide.py
Введите первое число: werq
Введите второе число: 3
Что-то пошло не так...
```

### try/except/finally
Блок finally это еще один опциональный блок в конструкции try. Он выполняется __всегда__, независимо от того, было ли исключение или нет.

Сюда ставятся действия, которые надо выполнить в любом случае. Например, это может быть закрытие файла.

Добавляем блок finally в наш скрипт:
```python
# -*- coding: utf-8 -*-

try:
    a = raw_input("Введите первое число: ")
    b = raw_input("Введите второе число: ")
    result = int(a)/int(b)
except (ValueError, ZeroDivisionError):
    print "Что-то пошло не так..."
else:
    print "Результат в квадрате: ", result**2
finally:
    print "Вот и сказочке конец, а кто слушал - молодец."
```

Проверяем:
```python
nata$ python divide.py
Введите первое число: 10
Введите второе число: 2
Результат в квадрате:  25
Вот и сказочке конец, а кто слушал - молодец.

nata$ python divide.py
Введите первое число: qwerewr
Введите второе число: 3
Что-то пошло не так...
Вот и сказочке конец, а кто слушал - молодец.

nata$ python divide.py
Введите первое число: 4
Введите второе число: 0
Что-то пошло не так...
Вот и сказочке конец, а кто слушал - молодец.
```
