## Группировка выражений
### Нумерованные группы
С помощью определения групп элементов в шаблоне, можно изолировать части текста, которые соответствуют шаблону.

Группа определяется помещением выражения в круглые скобки ```()```. 

Внутри выражения, группы нумеруются слева направо, начиная с 1. Затем к группам  можно обращаться к ним по номерам и получать текст, которые соответствует выражению в группе.

Пример использования групп:
```python
In [8]: line = '<text line> some text <12343>'
In [9]: match = re.search('(<.*?>).* (<\d+>)', line)
```

В данном примере у нас указаны две группы:
* первая группа - это любые символы заключенные в <>. Эта группа не жадная
* вторая группа - числа, заключенные в  <>

Теперь можно обращаться к группам по номеру. Группа 0 это строка, которая соответствует всему шаблону:
```python
In [10]: match.group(0)
Out[10]: '<text line> some text <12343>'

In [11]: match.group(1)
Out[11]: '<text line>'

In [12]: match.group(2)
Out[12]: '<12343>'
```

Для вывода всех подстрок, которые соответствуют указанным группам, используется метод groups:
```python
In [13]: match.groups()
Out[13]: ('<text line>', '<12343>')
```

### Именованные группы
Когда выражение сложное, становится сложнее определять номер группы, плюс, при дополнении выражения, может получиться так, что порядок групп изменился. И придется изменить и код, который ссылается на группы.

Синтаксис именованной группы __```(?P<name>regex)```__:
```python
In [14]: line = '<text line> some text <12343>'
In [14]: match = re.search('(?P<text><.*?>).* (?P<number><\d+>)', line)
```

Теперь к этим группа можно обращаться по имени:
```python
In [15]: match.group('text')
Out[15]: '<text line>'

In [16]: match.group('number')
Out[16]: '<12343>'
```

Также очень полезно то, что с помощью метода groupdict(), можно получить словарь, где ключи - имена групп, а значения - подстроки, которые им соответствуют:
```python
In [17]: match.groupdict()
Out[17]: {'number': '<12343>', 'text': '<text line>'}
```

