## Модуль sqlite3
Для работы с SQLite в Python используется модуль sqlite3.

Модуль sqlite3 предоставляет совместимый с DB-API 2.0 интерфейс для работы с SQLite.

Рассмотрим основные понятия, которые использует модуль для работы с SQLite.

### Connection
Объект __Connection__ - это подключение к конкретной БД, можно сказать, что этот объект представляет БД. Например, мы можем его создать так:
* ```conn = sqlite3.connect('dhcp_snooping.db')```

У объекта Connection есть несколько методов, с помощью которых, мы можем выполнять команды SQL:
* __execute()__ - метод для выполнения одного выражения SQL
* __executemany()__ - этот метод позволяет выполнить выражение SQL для последовательности параметров (или для итератора) 
* __executescript()__ - этот позволяет выполнить несколько выражений SQL за один раз

### Cursor
Для чтения данных из БД, используется объект Cursor - это основной способ работы с БД. Создается курсор из соединения с БД:
* ```cursor = sqlite3.connect('dhcp_snooping.db').cursor()```


> **Note** На самом деле, при использовании методов:
* Connection.execute() 
* Connection.executemany() 
* Connection.executescript()

> также создается курсор, но неявно, и фактически эти методы применяются к объекту Cursor.


При чтении данных, мы должны сначала выполнить выражение SQL, используя один из методов (описаны выше):
* __execute()__
* __executemany()__
* __executescript()__

А затем, с помощью метода fetch...(), мы обрабатываем полученные данные, и, в зависимости от метода, возвращаем их:
* __fetchone()__ - возвращает одну строку данных
* __fetchmany()__ - возвращает список строк данных. С помощью параметра size, можно указывать какое количество строк возвращается
* __fetchall()__ - возвращает все строки в результате запроса, в виде списка

### Connection как менеджер контекста
После выполнения всех необходимых операций, изменения должны быть сохранены (надо выполнить commit()), а затем можно закрыть курсор, если он больше не нужен.

При работе с SQLite, мы можем использовать объект Connection, как менеджер контекста и, в таком случае, нам не надо явно делать commit и закрывать соединение:
* при возникновении исключения, транзакция автоматически откатывается
* если исключения не было, автоматически выполняется commit

Пример использования соединения с базой, как менеджера контекстов:
* ```with sqlite3.connect('test.db') as conn```
